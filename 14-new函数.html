<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    function Dog(name, age) {
      this.name = name
      this.age = age
    }
    Dog.prototype.sayName = function () {
      console.log(this.name)
      console.log(this.age)
    }
    // 上面是本身Dog
    function _new(fn, ...args) {   // ...args为ES6展开符,也可以使用arguments
      //先用Object创建一个空的对象, 并将他爹原型上的属性或者方法给他
      const obj = Object.create(fn.prototype)  //fn.prototype代表 用当前对象的原型去创建
      //现在obj就代表Dog了,但是参数和this指向没有修改，他爹自己东西和后加进来的东西，改变this指向
      const rel = fn.apply(obj, args)
      //正常规定,如何fn返回的是null或undefined(也就是不返回内容),我们返回的是obj,否则返回rel  因为new的话会执行父函数
      return rel instanceof Object ? rel : obj
    }
    var _newDog = _new(Dog, '这是用_new出来的小狗', 'hehe')
    _newDog.sayName()
  </script>
</body>

</html>